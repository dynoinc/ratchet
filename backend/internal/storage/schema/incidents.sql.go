// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: incidents.sql

package schema

import (
	"context"

	dto "github.com/dynoinc/ratchet/internal/storage/schema/dto"
	"github.com/jackc/pgx/v5/pgtype"
)

const closeIncident = `-- name: CloseIncident :one
UPDATE incidents
SET end_timestamp = $1
WHERE incident_id = $2::integer
RETURNING incident_id
`

type CloseIncidentParams struct {
	EndTimestamp pgtype.Timestamptz
	IncidentID   int32
}

func (q *Queries) CloseIncident(ctx context.Context, arg CloseIncidentParams) (int32, error) {
	row := q.db.QueryRow(ctx, closeIncident, arg.EndTimestamp, arg.IncidentID)
	var incident_id int32
	err := row.Scan(&incident_id)
	return incident_id, err
}

const getIncidentStatsByPeriod = `-- name: GetIncidentStatsByPeriod :many
SELECT 
    priority as severity,
    COUNT(*) as count,
    AVG(EXTRACT(EPOCH FROM (end_timestamp - start_timestamp))) as avg_duration_seconds,
    SUM(EXTRACT(EPOCH FROM (end_timestamp - start_timestamp)))::float8 as total_duration_seconds
FROM incidents 
WHERE channel_id = $1 
    AND start_timestamp >= $2 
    AND start_timestamp <= $3
    AND end_timestamp IS NOT NULL
GROUP BY priority
ORDER BY priority
`

type GetIncidentStatsByPeriodParams struct {
	ChannelID        string
	StartTimestamp   pgtype.Timestamptz
	StartTimestamp_2 pgtype.Timestamptz
}

type GetIncidentStatsByPeriodRow struct {
	Severity             string
	Count                int64
	AvgDurationSeconds   float64
	TotalDurationSeconds float64
}

func (q *Queries) GetIncidentStatsByPeriod(ctx context.Context, arg GetIncidentStatsByPeriodParams) ([]GetIncidentStatsByPeriodRow, error) {
	rows, err := q.db.Query(ctx, getIncidentStatsByPeriod, arg.ChannelID, arg.StartTimestamp, arg.StartTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIncidentStatsByPeriodRow
	for rows.Next() {
		var i GetIncidentStatsByPeriodRow
		if err := rows.Scan(
			&i.Severity,
			&i.Count,
			&i.AvgDurationSeconds,
			&i.TotalDurationSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestIncidentBeforeTimestamp = `-- name: GetLatestIncidentBeforeTimestamp :one
SELECT incident_id, channel_id, slack_ts, alert, service, priority, attrs, start_timestamp, end_timestamp
FROM incidents
WHERE channel_id = $1
  AND alert = $2
  AND service = $3
  AND start_timestamp < $4
  AND end_timestamp IS NULL
ORDER BY start_timestamp DESC
LIMIT 1
`

type GetLatestIncidentBeforeTimestampParams struct {
	ChannelID       string
	Alert           string
	Service         string
	BeforeTimestamp pgtype.Timestamptz
}

func (q *Queries) GetLatestIncidentBeforeTimestamp(ctx context.Context, arg GetLatestIncidentBeforeTimestampParams) (Incident, error) {
	row := q.db.QueryRow(ctx, getLatestIncidentBeforeTimestamp,
		arg.ChannelID,
		arg.Alert,
		arg.Service,
		arg.BeforeTimestamp,
	)
	var i Incident
	err := row.Scan(
		&i.IncidentID,
		&i.ChannelID,
		&i.SlackTs,
		&i.Alert,
		&i.Service,
		&i.Priority,
		&i.Attrs,
		&i.StartTimestamp,
		&i.EndTimestamp,
	)
	return i, err
}

const getOpenIncidents = `-- name: GetOpenIncidents :many
SELECT incident_id, channel_id, slack_ts, alert, service, priority, attrs, start_timestamp, end_timestamp
FROM incidents
WHERE end_timestamp IS NULL
`

func (q *Queries) GetOpenIncidents(ctx context.Context) ([]Incident, error) {
	rows, err := q.db.Query(ctx, getOpenIncidents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incident
	for rows.Next() {
		var i Incident
		if err := rows.Scan(
			&i.IncidentID,
			&i.ChannelID,
			&i.SlackTs,
			&i.Alert,
			&i.Service,
			&i.Priority,
			&i.Attrs,
			&i.StartTimestamp,
			&i.EndTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopAlerts = `-- name: GetTopAlerts :many
SELECT 
    alert,
    COUNT(*) as count,
    MAX(start_timestamp) as last_seen,
    AVG(EXTRACT(EPOCH FROM (end_timestamp - start_timestamp))) as avg_duration_seconds
FROM incidents
WHERE channel_id = $1 
    AND start_timestamp >= $2 
    AND start_timestamp <= $3
    AND end_timestamp IS NOT NULL
GROUP BY alert
ORDER BY count DESC
LIMIT 5
`

type GetTopAlertsParams struct {
	ChannelID        string
	StartTimestamp   pgtype.Timestamptz
	StartTimestamp_2 pgtype.Timestamptz
}

type GetTopAlertsRow struct {
	Alert              string
	Count              int64
	LastSeen           interface{}
	AvgDurationSeconds float64
}

func (q *Queries) GetTopAlerts(ctx context.Context, arg GetTopAlertsParams) ([]GetTopAlertsRow, error) {
	rows, err := q.db.Query(ctx, getTopAlerts, arg.ChannelID, arg.StartTimestamp, arg.StartTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopAlertsRow
	for rows.Next() {
		var i GetTopAlertsRow
		if err := rows.Scan(
			&i.Alert,
			&i.Count,
			&i.LastSeen,
			&i.AvgDurationSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const openIncident = `-- name: OpenIncident :one
INSERT INTO incidents (
    channel_id,
    slack_ts,
    alert,
    service,
    priority,
    attrs,
    start_timestamp
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
ON CONFLICT (channel_id, slack_ts)
DO UPDATE SET
    alert = EXCLUDED.alert
RETURNING incident_id
`

type OpenIncidentParams struct {
	ChannelID      string
	SlackTs        string
	Alert          string
	Service        string
	Priority       string
	Attrs          dto.IncidentAttrs
	StartTimestamp pgtype.Timestamptz
}

func (q *Queries) OpenIncident(ctx context.Context, arg OpenIncidentParams) (int32, error) {
	row := q.db.QueryRow(ctx, openIncident,
		arg.ChannelID,
		arg.SlackTs,
		arg.Alert,
		arg.Service,
		arg.Priority,
		arg.Attrs,
		arg.StartTimestamp,
	)
	var incident_id int32
	err := row.Scan(&incident_id)
	return incident_id, err
}
