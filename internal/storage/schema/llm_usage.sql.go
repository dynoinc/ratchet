// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: llm_usage.sql

package schema

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteOldLLMUsage = `-- name: DeleteOldLLMUsage :exec
DELETE FROM llm_usage_v1
WHERE created_at < $1
`

func (q *Queries) DeleteOldLLMUsage(ctx context.Context, cutoffDate pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldLLMUsage, cutoffDate)
	return err
}

const getLLMUsageByTimeRange = `-- name: GetLLMUsageByTimeRange :many
SELECT 
    id,
    created_at,
    model,
    operation_type,
    prompt_text,
    completion_text,
    prompt_tokens,
    completion_tokens,
    total_tokens,
    latency_ms,
    status,
    error_message,
    metadata
FROM llm_usage_v1
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type GetLLMUsageByTimeRangeParams struct {
	StartTime     pgtype.Timestamptz
	EndTime       pgtype.Timestamptz
	ResultsOffset int32
	ResultsLimit  int32
}

func (q *Queries) GetLLMUsageByTimeRange(ctx context.Context, arg GetLLMUsageByTimeRangeParams) ([]LlmUsageV1, error) {
	rows, err := q.db.Query(ctx, getLLMUsageByTimeRange,
		arg.StartTime,
		arg.EndTime,
		arg.ResultsOffset,
		arg.ResultsLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmUsageV1
	for rows.Next() {
		var i LlmUsageV1
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Model,
			&i.OperationType,
			&i.PromptText,
			&i.CompletionText,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.TotalTokens,
			&i.LatencyMs,
			&i.Status,
			&i.ErrorMessage,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMUsageStats = `-- name: GetLLMUsageStats :one
SELECT 
    COUNT(*) as total_requests,
    SUM(prompt_tokens) as total_prompt_tokens,
    SUM(completion_tokens) as total_completion_tokens,
    SUM(total_tokens) as total_tokens,
    AVG(latency_ms) as avg_latency_ms,
    COUNT(CASE WHEN status = 'error' THEN 1 END) as error_count
FROM llm_usage_v1
WHERE created_at BETWEEN $1 AND $2
AND ($3 = '' OR model = $3)
AND ($4 = '' OR operation_type = $4)
`

type GetLLMUsageStatsParams struct {
	StartTime     pgtype.Timestamptz
	EndTime       pgtype.Timestamptz
	Model         interface{}
	OperationType interface{}
}

type GetLLMUsageStatsRow struct {
	TotalRequests         int64
	TotalPromptTokens     int64
	TotalCompletionTokens int64
	TotalTokens           int64
	AvgLatencyMs          float64
	ErrorCount            int64
}

func (q *Queries) GetLLMUsageStats(ctx context.Context, arg GetLLMUsageStatsParams) (GetLLMUsageStatsRow, error) {
	row := q.db.QueryRow(ctx, getLLMUsageStats,
		arg.StartTime,
		arg.EndTime,
		arg.Model,
		arg.OperationType,
	)
	var i GetLLMUsageStatsRow
	err := row.Scan(
		&i.TotalRequests,
		&i.TotalPromptTokens,
		&i.TotalCompletionTokens,
		&i.TotalTokens,
		&i.AvgLatencyMs,
		&i.ErrorCount,
	)
	return i, err
}

const recordLLMUsage = `-- name: RecordLLMUsage :one
INSERT INTO llm_usage_v1 (
    model,
    operation_type,
    prompt_text,
    completion_text,
    prompt_tokens,
    completion_tokens,
    total_tokens,
    latency_ms,
    status,
    error_message,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
) RETURNING id, created_at, model, operation_type, status
`

type RecordLLMUsageParams struct {
	Model            string
	OperationType    string
	PromptText       string
	CompletionText   *string
	PromptTokens     *int32
	CompletionTokens *int32
	TotalTokens      *int32
	LatencyMs        *int32
	Status           string
	ErrorMessage     *string
	Metadata         []byte
}

type RecordLLMUsageRow struct {
	ID            pgtype.UUID
	CreatedAt     pgtype.Timestamptz
	Model         string
	OperationType string
	Status        string
}

func (q *Queries) RecordLLMUsage(ctx context.Context, arg RecordLLMUsageParams) (RecordLLMUsageRow, error) {
	row := q.db.QueryRow(ctx, recordLLMUsage,
		arg.Model,
		arg.OperationType,
		arg.PromptText,
		arg.CompletionText,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.TotalTokens,
		arg.LatencyMs,
		arg.Status,
		arg.ErrorMessage,
		arg.Metadata,
	)
	var i RecordLLMUsageRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Model,
		&i.OperationType,
		&i.Status,
	)
	return i, err
}
