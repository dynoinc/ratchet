package slack_integration

//go:generate go tool mockgen -destination=mocks/mock_integration.go -package=mocks -source=slack.go Integration

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
	"github.com/slack-go/slack/socketmode"
)

type Config struct {
	BotToken   string `split_words:"true" required:"true"`
	AppToken   string `split_words:"true" required:"true"`
	DevChannel string `split_words:"true" default:"ratchet-test"`
}

type Integration interface {
	Run(ctx context.Context) error
	GetBotChannels() ([]slack.Channel, error)
	PostMessage(ctx context.Context, channelID string, messageBlocks ...slack.Block) error
	PostThreadReply(ctx context.Context, channelID, ts string, messageBlocks ...slack.Block) error
	Client() *slack.Client
	GetConversationInfo(ctx context.Context, channelID string) (*slack.Channel, error)
	GetConversationHistory(ctx context.Context, channelID string, lastNMsgs int) ([]slack.Message, error)
	GetConversationReplies(ctx context.Context, channelID, ts string) ([]slack.Message, error)
	BotUserID() string
	GetUserIDByEmail(ctx context.Context, email string) (string, error)
}

// CreateSignatureBlock creates a standardized signature block for Slack messages
// that includes metadata and a call for user feedback
func CreateSignatureBlock(moduleName string) []slack.Block {
	timestamp := time.Now().Format("2006-01-02 15:04:05 MST")
	signatureText := fmt.Sprintf("*Generated by Ratchet* [module:%s]\n"+
		"*Time:* %s\n\n"+
		"_React with :thumbsup: / :thumbsdown: to let us know if this was helpful!_",
		moduleName, timestamp)

	return []slack.Block{
		slack.NewDividerBlock(),
		slack.NewSectionBlock(
			&slack.TextBlockObject{
				Type: slack.MarkdownType,
				Text: signatureText,
			},
			nil,
			nil,
		),
	}
}

type handler interface {
	NotifyMessage(ctx context.Context, ev *slackevents.MessageEvent) error
	NotifyReactionAdded(ctx context.Context, ev *slackevents.ReactionAddedEvent) error
	NotifyReactionRemoved(ctx context.Context, ev *slackevents.ReactionRemovedEvent) error
}

type integration struct {
	c Config
	h handler

	botUserID string
	client    *socketmode.Client
}

func New(ctx context.Context, c Config, h handler) (Integration, error) {
	api := slack.New(c.BotToken, slack.OptionAppLevelToken(c.AppToken))

	authTest, err := api.AuthTestContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("slack API test failed: %w", err)
	}

	socketClient := socketmode.New(api)

	return &integration{
		c:         c,
		h:         h,
		botUserID: authTest.UserID,
		client:    socketClient,
	}, nil
}

func (b *integration) Run(ctx context.Context) error {
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case evt := <-b.client.Events:
				switch evt.Type {
				case socketmode.EventTypeEventsAPI:
					eventsAPI, ok := evt.Data.(slackevents.EventsAPIEvent)
					if !ok {
						continue
					}

					if err := b.handleEventAPI(ctx, eventsAPI); err != nil {
						slog.ErrorContext(ctx, "handling event", "error", err)
					}

					if err := b.client.AckCtx(ctx, evt.Request.EnvelopeID, nil); err != nil {
						slog.ErrorContext(ctx, "acknowledging event",
							"error", err,
							"envelope_id", evt.Request.EnvelopeID,
						)
					}
				}
			}
		}
	}()

	return b.client.RunContext(ctx)
}

func (b *integration) handleEventAPI(ctx context.Context, event slackevents.EventsAPIEvent) error {
	switch event.Type {
	case slackevents.CallbackEvent:
		switch ev := event.InnerEvent.Data.(type) {
		case *slackevents.MessageEvent:
			if err := b.h.NotifyMessage(ctx, ev); err != nil {
				return fmt.Errorf("notifying message for channel: %w", err)
			}
		case *slackevents.ReactionAddedEvent:
			if err := b.h.NotifyReactionAdded(ctx, ev); err != nil {
				return fmt.Errorf("notifying reaction added: %w", err)
			}
		case *slackevents.ReactionRemovedEvent:
			if err := b.h.NotifyReactionRemoved(ctx, ev); err != nil {
				return fmt.Errorf("notifying reaction removed: %w", err)
			}
		default:
			return fmt.Errorf("unhandled event: %T", ev)
		}
	default:
		return fmt.Errorf("unhandled event type: %s", event.Type)
	}

	return nil
}

func (b *integration) Client() *slack.Client {
	return &b.client.Client
}

func (b *integration) GetConversationInfo(ctx context.Context, channelID string) (*slack.Channel, error) {
	return b.client.GetConversationInfoContext(ctx, &slack.GetConversationInfoInput{
		ChannelID: channelID,
	})
}

func (b *integration) GetConversationHistory(ctx context.Context, channelID string, lastNMsgs int) ([]slack.Message, error) {
	params := &slack.GetConversationHistoryParameters{
		ChannelID: channelID,
		Latest:    timeToTs(time.Now()),
		Limit:     lastNMsgs,
	}
	var messages []slack.Message
	for {
		history, err := b.client.GetConversationHistoryContext(ctx, params)
		if err != nil {
			return nil, fmt.Errorf("getting conversation history for channel ID %s: %w", channelID, err)
		}

		messages = append(messages, history.Messages...)
		if !history.HasMore || len(messages) >= lastNMsgs {
			break
		}

		params.Cursor = history.ResponseMetadata.Cursor
		params.Latest = history.Messages[len(history.Messages)-1].Timestamp
	}

	return messages, nil
}

func (b *integration) GetConversationReplies(ctx context.Context, channelID, ts string) ([]slack.Message, error) {
	params := &slack.GetConversationRepliesParameters{
		ChannelID: channelID,
		Timestamp: ts,
	}

	var messages []slack.Message
	for {
		threadMessages, hasMore, nextCursor, err := b.client.GetConversationRepliesContext(ctx, params)
		if err != nil {
			return nil, fmt.Errorf("getting conversation replies for channel ID %s: %w", channelID, err)
		}

		messages = append(messages, threadMessages...)
		if !hasMore {
			break
		}

		params.Cursor = nextCursor
	}

	return messages, nil
}

func (b *integration) GetBotChannels() ([]slack.Channel, error) {
	params := &slack.GetConversationsForUserParameters{
		UserID:          b.botUserID,
		Types:           []string{"public_channel"},
		ExcludeArchived: true,
	}

	var channels []slack.Channel
	for {
		response, nextCursor, err := b.client.GetConversationsForUserContext(context.Background(), params)
		if err != nil {
			return nil, err
		}

		channels = append(channels, response...)

		if nextCursor == "" {
			break
		}

		params.Cursor = nextCursor
	}

	return channels, nil
}

func (b *integration) PostMessage(ctx context.Context, channelID string, messageBlocks ...slack.Block) error {
	if b.c.DevChannel != "" {
		channelID = b.c.DevChannel
	}

	_, _, err := b.client.PostMessageContext(
		ctx,
		channelID,
		slack.MsgOptionBlocks(messageBlocks...),
	)
	if err != nil {
		return fmt.Errorf("posting report message: %w", err)
	}

	return nil
}

func (b *integration) PostThreadReply(ctx context.Context, channelID, ts string, messageBlocks ...slack.Block) error {
	msgOptions := []slack.MsgOption{slack.MsgOptionBlocks(messageBlocks...)}
	if b.c.DevChannel != "" {
		channelID = b.c.DevChannel
	} else {
		msgOptions = append(msgOptions, slack.MsgOptionTS(ts))
	}

	if _, _, err := b.client.PostMessageContext(
		ctx,
		channelID,
		msgOptions...); err != nil {
		return fmt.Errorf("posting thread reply: %w", err)
	}

	return nil
}

func (b *integration) BotUserID() string {
	return b.botUserID
}

func (b *integration) GetUserIDByEmail(ctx context.Context, email string) (string, error) {
	user, err := b.client.GetUserByEmailContext(ctx, email)
	if err != nil {
		return "", fmt.Errorf("getting user by email %s: %w", email, err)
	}
	return user.ID, nil
}

func timeToTs(t time.Time) string {
	// Convert time.Time to Unix seconds and nanoseconds
	seconds := t.Unix()
	nanoseconds := int64(t.Nanosecond())

	// Convert Unix seconds and nanoseconds to a Slack timestamp
	return fmt.Sprintf("%d.%06d", seconds, nanoseconds/1000)
}
