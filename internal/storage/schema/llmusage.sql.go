// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: llmusage.sql

package schema

import (
	"context"

	dto "github.com/dynoinc/ratchet/internal/storage/schema/dto"
	"github.com/jackc/pgx/v5/pgtype"
)

const addLLMUsage = `-- name: AddLLMUsage :one
INSERT INTO
    llmusage (input, output, model, prompt)
VALUES
    ($1, $2, $3, $4)
RETURNING
    id, input, output, model, prompt, timestamp
`

type AddLLMUsageParams struct {
	Input  dto.LLMInput
	Output dto.LLMOutput
	Model  string
	Prompt string
}

func (q *Queries) AddLLMUsage(ctx context.Context, arg AddLLMUsageParams) (Llmusage, error) {
	row := q.db.QueryRow(ctx, addLLMUsage,
		arg.Input,
		arg.Output,
		arg.Model,
		arg.Prompt,
	)
	var i Llmusage
	err := row.Scan(
		&i.ID,
		&i.Input,
		&i.Output,
		&i.Model,
		&i.Prompt,
		&i.Timestamp,
	)
	return i, err
}

const getLLMUsageByID = `-- name: GetLLMUsageByID :one
SELECT
    id, input, output, model, prompt, timestamp
FROM
    llmusage
WHERE
    id = $1
`

func (q *Queries) GetLLMUsageByID(ctx context.Context, id int32) (Llmusage, error) {
	row := q.db.QueryRow(ctx, getLLMUsageByID, id)
	var i Llmusage
	err := row.Scan(
		&i.ID,
		&i.Input,
		&i.Output,
		&i.Model,
		&i.Prompt,
		&i.Timestamp,
	)
	return i, err
}

const getLLMUsageByModel = `-- name: GetLLMUsageByModel :many
SELECT
    id, input, output, model, prompt, timestamp
FROM
    llmusage
WHERE
    model = $1
ORDER BY
    timestamp DESC
LIMIT $3
OFFSET $2
`

type GetLLMUsageByModelParams struct {
	Model     string
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) GetLLMUsageByModel(ctx context.Context, arg GetLLMUsageByModelParams) ([]Llmusage, error) {
	rows, err := q.db.Query(ctx, getLLMUsageByModel, arg.Model, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmusage
	for rows.Next() {
		var i Llmusage
		if err := rows.Scan(
			&i.ID,
			&i.Input,
			&i.Output,
			&i.Model,
			&i.Prompt,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMUsageByTimeRange = `-- name: GetLLMUsageByTimeRange :many
SELECT
    id, input, output, model, prompt, timestamp
FROM
    llmusage
WHERE
    timestamp BETWEEN $1 AND $2
ORDER BY
    timestamp DESC
`

type GetLLMUsageByTimeRangeParams struct {
	StartTime pgtype.Timestamptz
	EndTime   pgtype.Timestamptz
}

func (q *Queries) GetLLMUsageByTimeRange(ctx context.Context, arg GetLLMUsageByTimeRangeParams) ([]Llmusage, error) {
	rows, err := q.db.Query(ctx, getLLMUsageByTimeRange, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmusage
	for rows.Next() {
		var i Llmusage
		if err := rows.Scan(
			&i.ID,
			&i.Input,
			&i.Output,
			&i.Model,
			&i.Prompt,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLLMUsage = `-- name: ListLLMUsage :many
SELECT
    id, input, output, model, prompt, timestamp
FROM
    llmusage
ORDER BY
    timestamp DESC
LIMIT $2
OFFSET $1
`

type ListLLMUsageParams struct {
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) ListLLMUsage(ctx context.Context, arg ListLLMUsageParams) ([]Llmusage, error) {
	rows, err := q.db.Query(ctx, listLLMUsage, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmusage
	for rows.Next() {
		var i Llmusage
		if err := rows.Scan(
			&i.ID,
			&i.Input,
			&i.Output,
			&i.Model,
			&i.Prompt,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
