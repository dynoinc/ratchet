package report_worker

import (
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/riverqueue/river"
	"github.com/slack-go/slack"

	"github.com/dynoinc/ratchet/internal/background"
	"github.com/dynoinc/ratchet/internal/report"
	"github.com/dynoinc/ratchet/internal/storage/schema"
)

type Worker struct {
	river.WorkerDefaults[background.WeeklyReportJobArgs]
	slack     *slack.Client
	generator *report.Generator
	db        *pgxpool.Pool
}

func New(slackClient *slack.Client, db *pgxpool.Pool) (*Worker, error) {
	generator, err := report.NewGenerator()
	if err != nil {
		return nil, err
	}

	return &Worker{
		slack:     slackClient,
		generator: generator,
		db:        db,
	}, nil
}

func (w *Worker) Work(ctx context.Context, job *river.Job[background.WeeklyReportJobArgs]) error {
	// Calculate the time range for the report
	endDate := time.Now()
	startDate := endDate.AddDate(0, 0, -7) // Last 7 days

	// Get incident statistics from database
	incidentStats, err := schema.New(w.db).GetIncidentStatsByPeriod(ctx, schema.GetIncidentStatsByPeriodParams{
		ChannelID: job.Args.ChannelID,
		StartTimestamp: pgtype.Timestamptz{
			Time:  startDate,
			Valid: true,
		},
		StartTimestamp_2: pgtype.Timestamptz{
			Time:  endDate,
			Valid: true,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to get incident stats: %w", err)
	}

	// Get top alerts from database
	topAlerts, err := schema.New(w.db).GetTopAlerts(ctx, schema.GetTopAlertsParams{
		ChannelID: job.Args.ChannelID,
		StartTimestamp: pgtype.Timestamptz{
			Time:  startDate,
			Valid: true,
		},
		StartTimestamp_2: pgtype.Timestamptz{
			Time:  endDate,
			Valid: true,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to get top alerts: %w", err)
	}

	// If there are no incidents or alerts, don't generate a report
	if len(incidentStats) == 0 && len(topAlerts) == 0 {
		// TODO: Remove this once we have real data
		incidentStats = []schema.GetIncidentStatsByPeriodRow{
			{Severity: "P0", Count: 0, AvgDurationSeconds: 0, TotalDurationSeconds: 0},
		}
		topAlerts = []schema.GetTopAlertsRow{
			{Alert: "Test Alert", Count: 0, LastSeen: time.Now(), AvgDurationSeconds: 0},
		}
	}

	// Generate the report using the database data
	report, err := w.generator.GenerateReport(job.Args.ChannelID, startDate, incidentStats, topAlerts)
	if err != nil {
		return fmt.Errorf("failed to generate report for channel %s: %w", job.Args.ChannelID, err)
	}

	// Create message blocks for better formatting
	blocks := []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "üìä Weekly Operations Report", true, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn",
				fmt.Sprintf("Channel: #%s\nüìÖ Week: %s",
					report.ChannelName,
					report.WeekRange,
				),
				false, false,
			),
			nil, nil,
		),
		// Incidents section header
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "üìà Incidents by Severity", true, false),
		),
		// Incidents table
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "```\n"+report.IncidentsByType+"```", false, false),
			nil, nil,
		),
		// Average mitigation time
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn",
				fmt.Sprintf("‚è±Ô∏è Average Mitigation Time: %s", report.AvgMitigationTime),
				false, false,
			),
			nil, nil,
		),
		// Top alerts section header
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "üî• Top Alerts", true, false),
		),
		// Top alerts table
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "```\n"+report.TopAlerts+"```", false, false),
			nil, nil,
		),
		// Footer
		slack.NewContextBlock(
			"footer",
			slack.NewTextBlockObject(
				"mrkdwn",
				fmt.Sprintf("ü§ñ Generated by Ratchet Bot | %s", time.Now().Format(time.RFC1123)),
				false, false,
			),
		),
	}

	_, _, err = w.slack.PostMessage(
		job.Args.ChannelID,
		slack.MsgOptionBlocks(blocks...),
	)
	if err != nil {
		return fmt.Errorf("failed to post report to channel %s: %w", job.Args.ChannelID, err)
	}

	return nil
}
